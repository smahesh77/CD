# Detailed Flex and Bison Calculator Explanation

This document provides an in-depth explanation of a simple calculator implemented using Flex (lexical analyzer) and Bison (parser generator). The calculator can perform basic arithmetic operations (+, -, *, /) and handle parentheses.

## Part 1: Flex (Lexer)

```lex
%option noyywrap

%{
#include "y.tab.h"
%}

DIGIT [0-9]
NUMBER {DIGIT}+
PLUS "+"
MINUS "-"
MULT "*"
DIV "/"
LPAREN "("
RPAREN ")"
WS [ \t\r\n]+

%%
{NUMBER}  { yylval = atoi(yytext); return NUMBER; }
{PLUS}    { return PLUS; }
{MINUS}   { return MINUS; }
{MULT}    { return MULT; }
{DIV}     { return DIV; }
{LPAREN}  { return LPAREN; }
{RPAREN}  { return RPAREN; }
{WS}      { /* ignore whitespace */ }
\n        { /* ignore newline */ }
.         { printf("Invalid character: %c\n", *yytext); }
%%
```

### Detailed Explanation:

1. `%option noyywrap`:
   - This option tells Flex not to use the default `yywrap()` function.
   - `yywrap()` is normally called when the lexer reaches the end of the input. By disabling it, we're saying our lexer only processes a single input stream.

2. `%{ #include "y.tab.h" %}`:
   - This block includes the header file generated by Bison.
   - `y.tab.h` contains definitions for the tokens used by both the lexer and parser.

3. Token Definitions:
   - `DIGIT [0-9]`: Defines a digit as any character from 0 to 9.
   - `NUMBER {DIGIT}+`: Defines a number as one or more digits.
   - `PLUS "+"`, `MINUS "-"`, etc.: Define the arithmetic operators and parentheses.
   - `WS [ \t\r\n]+`: Defines whitespace as one or more space, tab, carriage return, or newline characters.

4. Rules Section:
   - `{NUMBER}  { yylval = atoi(yytext); return NUMBER; }`:
     * When a number is matched, convert it to an integer with `atoi()`.
     * Store the value in `yylval`, which is used to pass values from the lexer to the parser.
     * Return the `NUMBER` token to the parser.
   - `{PLUS}    { return PLUS; }`, etc.:
     * For operators and parentheses, simply return the corresponding token.
   - `{WS}      { /* ignore whitespace */ }`:
     * Whitespace is ignored (no action taken).
   - `\n        { /* ignore newline */ }`:
     * Newlines are also ignored.
   - `. { printf("Invalid character: %c\n", *yytext); }`:
     * This is a catch-all rule for any character not matched by previous rules.
     * It prints an error message for invalid characters.

## Part 2: Bison (Parser)

```bison
%{
#include <stdio.h>
#include <stdlib.h>

extern int yylex(void);
extern int yyparse(void);
extern FILE *yyin;

void yyerror(const char *msg) {
    fprintf(stderr, "Error: %s\n", msg);
}

int result; // Variable to store the result
%}

%token NUMBER PLUS MINUS MULT DIV LPAREN RPAREN

%left PLUS MINUS
%left MULT DIV

%%

expression:
    term { result = $1; }
    | expression PLUS term { result = $1 + $3; }
    | expression MINUS term { result = $1 - $3; }
    ;

term:
    factor { $$ = $1; }
    | term MULT factor { $$ = $1 * $3; }
    | term DIV factor { $$ = $1 / $3; }
    ;

factor:
    NUMBER { $$ = $1; }
    | LPAREN expression RPAREN { $$ = result; }
    ;

%%

int main() {
    char input[256];
    
    while (1) {
        printf("Enter an expression (or 'q' to quit): ");
        if (fgets(input, sizeof(input), stdin) == NULL) {
            break;
        }
        
        if (input[0] == 'q' || input[0] == 'Q') {
            break;
        }
        
        yyin = fopen("temp", "w");
        if (!yyin) {
            fprintf(stderr, "Could not open temporary file\n");
            return 1;
        }
        
        fprintf(yyin, "%s", input);
        fclose(yyin);
        
        yyin = fopen("temp", "r");
        if (!yyin) {
            fprintf(stderr, "Could not open temporary file\n");
            return 1;
        }
        
        yyparse();
        printf("Result: %d\n", result);
    }
    
    return 0;
}
```

### Detailed Explanation:

1. Prologue (`%{ ... %}` block):
   - Includes necessary header files.
   - Declares external functions `yylex()` and `yyparse()`, which are generated by Flex and Bison respectively.
   - Declares `yyin`, which is the input file pointer used by Flex.
   - Defines `yyerror()` function for error reporting.
   - Declares `result` variable to store the final calculation result.

2. Token Declarations:
   - `%token NUMBER PLUS MINUS MULT DIV LPAREN RPAREN`:
     * Declares the tokens that will be used in the grammar rules.
     * These correspond to the tokens returned by the lexer.

3. Operator Precedence:
   - `%left PLUS MINUS` and `%left MULT DIV`:
     * Defines operator associativity (left-associative in this case) and precedence.
     * Multiplication and division have higher precedence than addition and subtraction.

4. Grammar Rules:
   - `expression`:
     * Can be a single term, or an expression followed by PLUS or MINUS and another term.
     * The `result` variable is updated with each operation.
   - `term`:
     * Can be a single factor, or a term followed by MULT or DIV and another factor.
     * `$$` represents the value of the current non-terminal (term in this case).
     * `$1`, `$3` refer to the values of the 1st and 3rd components in the rule.
   - `factor`:
     * Can be a NUMBER or a parenthesized expression.
     * For parenthesized expressions, it uses the `result` variable.

5. Main Function:
   - Implements a loop for continuous input:
     * Prompts the user for input.
     * Allows quitting with 'q' or 'Q'.
   - Uses a temporary file for input:
     * Opens a temporary file in write mode.
     * Writes the user input to this file.
     * Closes and reopens the file in read mode.
   - Calls `yyparse()` to parse the input and compute the result.
   - Prints the final result stored in the `result` variable.

## How It All Works Together

1. The main function prompts for user input and writes it to a temporary file.
2. Flex reads from this file (`yyin`) and tokenizes the input.
3. For each token, Flex returns a token type to Bison (e.g., NUMBER, PLUS, etc.).
4. Bison uses these tokens to build the parse tree according to the grammar rules.
5. As Bison reduces expressions, it performs the calculations and updates the `result` variable.
6. After parsing is complete, the main function prints the final result.

This implementation allows for basic arithmetic operations with proper precedence and parentheses handling. However, it uses integers only and doesn't handle floating-point numbers or more complex mathematical functions.

The use of a temporary file in the main function is an interesting choice. While it works, a more common approach would be to use a string buffer or to have Flex read directly from stdin.
